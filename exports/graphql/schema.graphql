input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type AddressType {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  isActive: Boolean
  published_at: DateTime
}

type AddressTypeConnection {
  values: [AddressType]
  groupBy: AddressTypeGroupBy
  aggregate: AddressTypeAggregator
}

type AddressTypeAggregator {
  count: Int
  totalCount: Int
}

type AddressTypeGroupBy {
  id: [AddressTypeConnectionId]
  created_at: [AddressTypeConnectionCreated_at]
  updated_at: [AddressTypeConnectionUpdated_at]
  name: [AddressTypeConnectionName]
  isActive: [AddressTypeConnectionIsActive]
  published_at: [AddressTypeConnectionPublished_at]
}

type AddressTypeConnectionId {
  key: ID
  connection: AddressTypeConnection
}

type AddressTypeConnectionCreated_at {
  key: DateTime
  connection: AddressTypeConnection
}

type AddressTypeConnectionUpdated_at {
  key: DateTime
  connection: AddressTypeConnection
}

type AddressTypeConnectionName {
  key: String
  connection: AddressTypeConnection
}

type AddressTypeConnectionIsActive {
  key: Boolean
  connection: AddressTypeConnection
}

type AddressTypeConnectionPublished_at {
  key: DateTime
  connection: AddressTypeConnection
}

input AddressTypeInput {
  name: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editAddressTypeInput {
  name: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createAddressTypeInput {
  data: AddressTypeInput
}

type createAddressTypePayload {
  addressType: AddressType
}

input updateAddressTypeInput {
  where: InputID
  data: editAddressTypeInput
}

type updateAddressTypePayload {
  addressType: AddressType
}

input deleteAddressTypeInput {
  where: InputID
}

type deleteAddressTypePayload {
  addressType: AddressType
}

type Address {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  city: City
  state: State
  country: Country
  streetaddress: String!
  published_at: DateTime
  address_types(sort: String, limit: Int, start: Int, where: JSON): [AddressType]
  userAddresses(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type AddressConnection {
  values: [Address]
  groupBy: AddressGroupBy
  aggregate: AddressAggregator
}

type AddressAggregator {
  count: Int
  totalCount: Int
}

type AddressGroupBy {
  id: [AddressConnectionId]
  created_at: [AddressConnectionCreated_at]
  updated_at: [AddressConnectionUpdated_at]
  city: [AddressConnectionCity]
  state: [AddressConnectionState]
  country: [AddressConnectionCountry]
  streetaddress: [AddressConnectionStreetaddress]
  published_at: [AddressConnectionPublished_at]
}

type AddressConnectionId {
  key: ID
  connection: AddressConnection
}

type AddressConnectionCreated_at {
  key: DateTime
  connection: AddressConnection
}

type AddressConnectionUpdated_at {
  key: DateTime
  connection: AddressConnection
}

type AddressConnectionCity {
  key: ID
  connection: AddressConnection
}

type AddressConnectionState {
  key: ID
  connection: AddressConnection
}

type AddressConnectionCountry {
  key: ID
  connection: AddressConnection
}

type AddressConnectionStreetaddress {
  key: String
  connection: AddressConnection
}

type AddressConnectionPublished_at {
  key: DateTime
  connection: AddressConnection
}

input AddressInput {
  city: ID
  state: ID
  country: ID
  address_types: [ID]
  streetaddress: String!
  userAddresses: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editAddressInput {
  city: ID
  state: ID
  country: ID
  address_types: [ID]
  streetaddress: String
  userAddresses: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createAddressInput {
  data: AddressInput
}

type createAddressPayload {
  address: Address
}

input updateAddressInput {
  where: InputID
  data: editAddressInput
}

type updateAddressPayload {
  address: Address
}

input deleteAddressInput {
  where: InputID
}

type deleteAddressPayload {
  address: Address
}

type City {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  cityName: String!
  isActive: Boolean!
  published_at: DateTime
}

type CityConnection {
  values: [City]
  groupBy: CityGroupBy
  aggregate: CityAggregator
}

type CityAggregator {
  count: Int
  totalCount: Int
}

type CityGroupBy {
  id: [CityConnectionId]
  created_at: [CityConnectionCreated_at]
  updated_at: [CityConnectionUpdated_at]
  cityName: [CityConnectionCityName]
  isActive: [CityConnectionIsActive]
  published_at: [CityConnectionPublished_at]
}

type CityConnectionId {
  key: ID
  connection: CityConnection
}

type CityConnectionCreated_at {
  key: DateTime
  connection: CityConnection
}

type CityConnectionUpdated_at {
  key: DateTime
  connection: CityConnection
}

type CityConnectionCityName {
  key: String
  connection: CityConnection
}

type CityConnectionIsActive {
  key: Boolean
  connection: CityConnection
}

type CityConnectionPublished_at {
  key: DateTime
  connection: CityConnection
}

input CityInput {
  cityName: String!
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCityInput {
  cityName: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCityInput {
  data: CityInput
}

type createCityPayload {
  city: City
}

input updateCityInput {
  where: InputID
  data: editCityInput
}

type updateCityPayload {
  city: City
}

input deleteCityInput {
  where: InputID
}

type deleteCityPayload {
  city: City
}

type Commission {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  store: Store
  value: Float
  type: String
}

type CommissionConnection {
  values: [Commission]
  groupBy: CommissionGroupBy
  aggregate: CommissionAggregator
}

type CommissionAggregator {
  count: Int
  totalCount: Int
  sum: CommissionAggregatorSum
  avg: CommissionAggregatorAvg
  min: CommissionAggregatorMin
  max: CommissionAggregatorMax
}

type CommissionAggregatorSum {
  value: Float
}

type CommissionAggregatorAvg {
  value: Float
}

type CommissionAggregatorMin {
  value: Float
}

type CommissionAggregatorMax {
  value: Float
}

type CommissionGroupBy {
  id: [CommissionConnectionId]
  created_at: [CommissionConnectionCreated_at]
  updated_at: [CommissionConnectionUpdated_at]
  name: [CommissionConnectionName]
  store: [CommissionConnectionStore]
  value: [CommissionConnectionValue]
  type: [CommissionConnectionType]
}

type CommissionConnectionId {
  key: ID
  connection: CommissionConnection
}

type CommissionConnectionCreated_at {
  key: DateTime
  connection: CommissionConnection
}

type CommissionConnectionUpdated_at {
  key: DateTime
  connection: CommissionConnection
}

type CommissionConnectionName {
  key: String
  connection: CommissionConnection
}

type CommissionConnectionStore {
  key: ID
  connection: CommissionConnection
}

type CommissionConnectionValue {
  key: Float
  connection: CommissionConnection
}

type CommissionConnectionType {
  key: String
  connection: CommissionConnection
}

input CommissionInput {
  name: String
  store: ID
  value: Float
  type: String
  created_by: ID
  updated_by: ID
}

input editCommissionInput {
  name: String
  store: ID
  value: Float
  type: String
  created_by: ID
  updated_by: ID
}

input createCommissionInput {
  data: CommissionInput
}

type createCommissionPayload {
  commission: Commission
}

input updateCommissionInput {
  where: InputID
  data: editCommissionInput
}

type updateCommissionPayload {
  commission: Commission
}

input deleteCommissionInput {
  where: InputID
}

type deleteCommissionPayload {
  commission: Commission
}

type Country {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  countryName: String!
  isActive: Boolean!
  published_at: DateTime
}

type CountryConnection {
  values: [Country]
  groupBy: CountryGroupBy
  aggregate: CountryAggregator
}

type CountryAggregator {
  count: Int
  totalCount: Int
}

type CountryGroupBy {
  id: [CountryConnectionId]
  created_at: [CountryConnectionCreated_at]
  updated_at: [CountryConnectionUpdated_at]
  countryName: [CountryConnectionCountryName]
  isActive: [CountryConnectionIsActive]
  published_at: [CountryConnectionPublished_at]
}

type CountryConnectionId {
  key: ID
  connection: CountryConnection
}

type CountryConnectionCreated_at {
  key: DateTime
  connection: CountryConnection
}

type CountryConnectionUpdated_at {
  key: DateTime
  connection: CountryConnection
}

type CountryConnectionCountryName {
  key: String
  connection: CountryConnection
}

type CountryConnectionIsActive {
  key: Boolean
  connection: CountryConnection
}

type CountryConnectionPublished_at {
  key: DateTime
  connection: CountryConnection
}

input CountryInput {
  countryName: String!
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCountryInput {
  countryName: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCountryInput {
  data: CountryInput
}

type createCountryPayload {
  country: Country
}

input updateCountryInput {
  where: InputID
  data: editCountryInput
}

type updateCountryPayload {
  country: Country
}

input deleteCountryInput {
  where: InputID
}

type deleteCountryPayload {
  country: Country
}

type DeleveiryCharges {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  DistanceFrom: Int
  DistanceTo: Int
  Rate: Float
  published_at: DateTime
}

type DeleveiryChargesConnection {
  values: [DeleveiryCharges]
  groupBy: DeleveiryChargesGroupBy
  aggregate: DeleveiryChargesAggregator
}

type DeleveiryChargesAggregator {
  count: Int
  totalCount: Int
  sum: DeleveiryChargesAggregatorSum
  avg: DeleveiryChargesAggregatorAvg
  min: DeleveiryChargesAggregatorMin
  max: DeleveiryChargesAggregatorMax
}

type DeleveiryChargesAggregatorSum {
  DistanceFrom: Float
  DistanceTo: Float
  Rate: Float
}

type DeleveiryChargesAggregatorAvg {
  DistanceFrom: Float
  DistanceTo: Float
  Rate: Float
}

type DeleveiryChargesAggregatorMin {
  DistanceFrom: Float
  DistanceTo: Float
  Rate: Float
}

type DeleveiryChargesAggregatorMax {
  DistanceFrom: Float
  DistanceTo: Float
  Rate: Float
}

type DeleveiryChargesGroupBy {
  id: [DeleveiryChargesConnectionId]
  created_at: [DeleveiryChargesConnectionCreated_at]
  updated_at: [DeleveiryChargesConnectionUpdated_at]
  DistanceFrom: [DeleveiryChargesConnectionDistanceFrom]
  DistanceTo: [DeleveiryChargesConnectionDistanceTo]
  Rate: [DeleveiryChargesConnectionRate]
  published_at: [DeleveiryChargesConnectionPublished_at]
}

type DeleveiryChargesConnectionId {
  key: ID
  connection: DeleveiryChargesConnection
}

type DeleveiryChargesConnectionCreated_at {
  key: DateTime
  connection: DeleveiryChargesConnection
}

type DeleveiryChargesConnectionUpdated_at {
  key: DateTime
  connection: DeleveiryChargesConnection
}

type DeleveiryChargesConnectionDistanceFrom {
  key: Int
  connection: DeleveiryChargesConnection
}

type DeleveiryChargesConnectionDistanceTo {
  key: Int
  connection: DeleveiryChargesConnection
}

type DeleveiryChargesConnectionRate {
  key: Float
  connection: DeleveiryChargesConnection
}

type DeleveiryChargesConnectionPublished_at {
  key: DateTime
  connection: DeleveiryChargesConnection
}

input DeleveiryChargeInput {
  DistanceFrom: Int
  DistanceTo: Int
  Rate: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDeleveiryChargeInput {
  DistanceFrom: Int
  DistanceTo: Int
  Rate: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDeleveiryChargeInput {
  data: DeleveiryChargeInput
}

type createDeleveiryChargePayload {
  deleveiryCharge: DeleveiryCharges
}

input updateDeleveiryChargeInput {
  where: InputID
  data: editDeleveiryChargeInput
}

type updateDeleveiryChargePayload {
  deleveiryCharge: DeleveiryCharges
}

input deleteDeleveiryChargeInput {
  where: InputID
}

type deleteDeleveiryChargePayload {
  deleveiryCharge: DeleveiryCharges
}

type DeliverType {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  IsActive: Boolean
  published_at: DateTime
  stores(sort: String, limit: Int, start: Int, where: JSON): [Store]
}

type DeliverTypeConnection {
  values: [DeliverType]
  groupBy: DeliverTypeGroupBy
  aggregate: DeliverTypeAggregator
}

type DeliverTypeAggregator {
  count: Int
  totalCount: Int
}

type DeliverTypeGroupBy {
  id: [DeliverTypeConnectionId]
  created_at: [DeliverTypeConnectionCreated_at]
  updated_at: [DeliverTypeConnectionUpdated_at]
  Name: [DeliverTypeConnectionName]
  IsActive: [DeliverTypeConnectionIsActive]
  published_at: [DeliverTypeConnectionPublished_at]
}

type DeliverTypeConnectionId {
  key: ID
  connection: DeliverTypeConnection
}

type DeliverTypeConnectionCreated_at {
  key: DateTime
  connection: DeliverTypeConnection
}

type DeliverTypeConnectionUpdated_at {
  key: DateTime
  connection: DeliverTypeConnection
}

type DeliverTypeConnectionName {
  key: String
  connection: DeliverTypeConnection
}

type DeliverTypeConnectionIsActive {
  key: Boolean
  connection: DeliverTypeConnection
}

type DeliverTypeConnectionPublished_at {
  key: DateTime
  connection: DeliverTypeConnection
}

input DeliverTypeInput {
  Name: String
  IsActive: Boolean
  stores: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDeliverTypeInput {
  Name: String
  IsActive: Boolean
  stores: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDeliverTypeInput {
  data: DeliverTypeInput
}

type createDeliverTypePayload {
  deliverType: DeliverType
}

input updateDeliverTypeInput {
  where: InputID
  data: editDeliverTypeInput
}

type updateDeliverTypePayload {
  deliverType: DeliverType
}

input deleteDeliverTypeInput {
  where: InputID
}

type deleteDeliverTypePayload {
  deliverType: DeliverType
}

type Delivers {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  IsActive: Boolean
  published_at: DateTime
  stores(sort: String, limit: Int, start: Int, where: JSON): [Store]
}

type DeliversConnection {
  values: [Delivers]
  groupBy: DeliversGroupBy
  aggregate: DeliversAggregator
}

type DeliversAggregator {
  count: Int
  totalCount: Int
}

type DeliversGroupBy {
  id: [DeliversConnectionId]
  created_at: [DeliversConnectionCreated_at]
  updated_at: [DeliversConnectionUpdated_at]
  Name: [DeliversConnectionName]
  IsActive: [DeliversConnectionIsActive]
  published_at: [DeliversConnectionPublished_at]
}

type DeliversConnectionId {
  key: ID
  connection: DeliversConnection
}

type DeliversConnectionCreated_at {
  key: DateTime
  connection: DeliversConnection
}

type DeliversConnectionUpdated_at {
  key: DateTime
  connection: DeliversConnection
}

type DeliversConnectionName {
  key: String
  connection: DeliversConnection
}

type DeliversConnectionIsActive {
  key: Boolean
  connection: DeliversConnection
}

type DeliversConnectionPublished_at {
  key: DateTime
  connection: DeliversConnection
}

input DeliverInput {
  Name: String
  IsActive: Boolean
  stores: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDeliverInput {
  Name: String
  IsActive: Boolean
  stores: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDeliverInput {
  data: DeliverInput
}

type createDeliverPayload {
  deliver: Delivers
}

input updateDeliverInput {
  where: InputID
  data: editDeliverInput
}

type updateDeliverPayload {
  deliver: Delivers
}

input deleteDeliverInput {
  where: InputID
}

type deleteDeliverPayload {
  deliver: Delivers
}

type DeliveryDays {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  DaysName: String
  DaysId: String
  IsActive: Boolean
  published_at: DateTime
  stores(sort: String, limit: Int, start: Int, where: JSON): [Store]
  product_categories(sort: String, limit: Int, start: Int, where: JSON): [MenuCategory]
  promotions(sort: String, limit: Int, start: Int, where: JSON): [Promotions]
}

type DeliveryDaysConnection {
  values: [DeliveryDays]
  groupBy: DeliveryDaysGroupBy
  aggregate: DeliveryDaysAggregator
}

type DeliveryDaysAggregator {
  count: Int
  totalCount: Int
}

type DeliveryDaysGroupBy {
  id: [DeliveryDaysConnectionId]
  created_at: [DeliveryDaysConnectionCreated_at]
  updated_at: [DeliveryDaysConnectionUpdated_at]
  DaysName: [DeliveryDaysConnectionDaysName]
  DaysId: [DeliveryDaysConnectionDaysId]
  IsActive: [DeliveryDaysConnectionIsActive]
  published_at: [DeliveryDaysConnectionPublished_at]
}

type DeliveryDaysConnectionId {
  key: ID
  connection: DeliveryDaysConnection
}

type DeliveryDaysConnectionCreated_at {
  key: DateTime
  connection: DeliveryDaysConnection
}

type DeliveryDaysConnectionUpdated_at {
  key: DateTime
  connection: DeliveryDaysConnection
}

type DeliveryDaysConnectionDaysName {
  key: String
  connection: DeliveryDaysConnection
}

type DeliveryDaysConnectionDaysId {
  key: String
  connection: DeliveryDaysConnection
}

type DeliveryDaysConnectionIsActive {
  key: Boolean
  connection: DeliveryDaysConnection
}

type DeliveryDaysConnectionPublished_at {
  key: DateTime
  connection: DeliveryDaysConnection
}

input DeliveryDayInput {
  DaysName: String
  DaysId: String
  IsActive: Boolean
  stores: [ID]
  product_categories: [ID]
  promotions: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDeliveryDayInput {
  DaysName: String
  DaysId: String
  IsActive: Boolean
  stores: [ID]
  product_categories: [ID]
  promotions: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDeliveryDayInput {
  data: DeliveryDayInput
}

type createDeliveryDayPayload {
  deliveryDay: DeliveryDays
}

input updateDeliveryDayInput {
  where: InputID
  data: editDeliveryDayInput
}

type updateDeliveryDayPayload {
  deliveryDay: DeliveryDays
}

input deleteDeliveryDayInput {
  where: InputID
}

type deleteDeliveryDayPayload {
  deliveryDay: DeliveryDays
}

type MenuCategory {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  IsActive: Boolean
  IsDisplayable: Boolean
  Image: UploadFile
  price: Float
  pricey: Float
  published_at: DateTime
  stores(sort: String, limit: Int, start: Int, where: JSON): [Store]
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
  delivery_days(sort: String, limit: Int, start: Int, where: JSON): [DeliveryDays]
  promotions(sort: String, limit: Int, start: Int, where: JSON): [Promotions]
}

type MenuCategoryConnection {
  values: [MenuCategory]
  groupBy: MenuCategoryGroupBy
  aggregate: MenuCategoryAggregator
}

type MenuCategoryAggregator {
  count: Int
  totalCount: Int
  sum: MenuCategoryAggregatorSum
  avg: MenuCategoryAggregatorAvg
  min: MenuCategoryAggregatorMin
  max: MenuCategoryAggregatorMax
}

type MenuCategoryAggregatorSum {
  price: Float
  pricey: Float
}

type MenuCategoryAggregatorAvg {
  price: Float
  pricey: Float
}

type MenuCategoryAggregatorMin {
  price: Float
  pricey: Float
}

type MenuCategoryAggregatorMax {
  price: Float
  pricey: Float
}

type MenuCategoryGroupBy {
  id: [MenuCategoryConnectionId]
  created_at: [MenuCategoryConnectionCreated_at]
  updated_at: [MenuCategoryConnectionUpdated_at]
  Name: [MenuCategoryConnectionName]
  IsActive: [MenuCategoryConnectionIsActive]
  IsDisplayable: [MenuCategoryConnectionIsDisplayable]
  Image: [MenuCategoryConnectionImage]
  price: [MenuCategoryConnectionPrice]
  pricey: [MenuCategoryConnectionPricey]
  published_at: [MenuCategoryConnectionPublished_at]
}

type MenuCategoryConnectionId {
  key: ID
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionCreated_at {
  key: DateTime
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionUpdated_at {
  key: DateTime
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionName {
  key: String
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionIsActive {
  key: Boolean
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionIsDisplayable {
  key: Boolean
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionImage {
  key: ID
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionPrice {
  key: Float
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionPricey {
  key: Float
  connection: MenuCategoryConnection
}

type MenuCategoryConnectionPublished_at {
  key: DateTime
  connection: MenuCategoryConnection
}

input MenuCategoryInput {
  Name: String
  IsActive: Boolean
  stores: [ID]
  products: [ID]
  IsDisplayable: Boolean
  Image: ID
  delivery_days: [ID]
  price: Float
  pricey: Float
  promotions: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMenuCategoryInput {
  Name: String
  IsActive: Boolean
  stores: [ID]
  products: [ID]
  IsDisplayable: Boolean
  Image: ID
  delivery_days: [ID]
  price: Float
  pricey: Float
  promotions: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMenuCategoryInput {
  data: MenuCategoryInput
}

type createMenuCategoryPayload {
  menuCategory: MenuCategory
}

input updateMenuCategoryInput {
  where: InputID
  data: editMenuCategoryInput
}

type updateMenuCategoryPayload {
  menuCategory: MenuCategory
}

input deleteMenuCategoryInput {
  where: InputID
}

type deleteMenuCategoryPayload {
  menuCategory: MenuCategory
}

type OrderDetail {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  isActive: Boolean
  isOffer: Boolean
  Amount: String!
  published_at: DateTime
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type OrderDetailConnection {
  values: [OrderDetail]
  groupBy: OrderDetailGroupBy
  aggregate: OrderDetailAggregator
}

type OrderDetailAggregator {
  count: Int
  totalCount: Int
}

type OrderDetailGroupBy {
  id: [OrderDetailConnectionId]
  created_at: [OrderDetailConnectionCreated_at]
  updated_at: [OrderDetailConnectionUpdated_at]
  isActive: [OrderDetailConnectionIsActive]
  isOffer: [OrderDetailConnectionIsOffer]
  Amount: [OrderDetailConnectionAmount]
  published_at: [OrderDetailConnectionPublished_at]
}

type OrderDetailConnectionId {
  key: ID
  connection: OrderDetailConnection
}

type OrderDetailConnectionCreated_at {
  key: DateTime
  connection: OrderDetailConnection
}

type OrderDetailConnectionUpdated_at {
  key: DateTime
  connection: OrderDetailConnection
}

type OrderDetailConnectionIsActive {
  key: Boolean
  connection: OrderDetailConnection
}

type OrderDetailConnectionIsOffer {
  key: Boolean
  connection: OrderDetailConnection
}

type OrderDetailConnectionAmount {
  key: String
  connection: OrderDetailConnection
}

type OrderDetailConnectionPublished_at {
  key: DateTime
  connection: OrderDetailConnection
}

input OrderDetailInput {
  isActive: Boolean
  isOffer: Boolean
  Amount: String!
  orders: [ID]
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editOrderDetailInput {
  isActive: Boolean
  isOffer: Boolean
  Amount: String
  orders: [ID]
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createOrderDetailInput {
  data: OrderDetailInput
}

type createOrderDetailPayload {
  orderDetail: OrderDetail
}

input updateOrderDetailInput {
  where: InputID
  data: editOrderDetailInput
}

type updateOrderDetailPayload {
  orderDetail: OrderDetail
}

input deleteOrderDetailInput {
  where: InputID
}

type deleteOrderDetailPayload {
  orderDetail: OrderDetail
}

type OrderHistory {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  OrderName: String
  order: Order
  payment_status: String
  published_at: DateTime
  order_statuses(sort: String, limit: Int, start: Int, where: JSON): [OrderStatus]
}

type OrderHistoryConnection {
  values: [OrderHistory]
  groupBy: OrderHistoryGroupBy
  aggregate: OrderHistoryAggregator
}

type OrderHistoryAggregator {
  count: Int
  totalCount: Int
}

type OrderHistoryGroupBy {
  id: [OrderHistoryConnectionId]
  created_at: [OrderHistoryConnectionCreated_at]
  updated_at: [OrderHistoryConnectionUpdated_at]
  OrderName: [OrderHistoryConnectionOrderName]
  order: [OrderHistoryConnectionOrder]
  payment_status: [OrderHistoryConnectionPayment_status]
  published_at: [OrderHistoryConnectionPublished_at]
}

type OrderHistoryConnectionId {
  key: ID
  connection: OrderHistoryConnection
}

type OrderHistoryConnectionCreated_at {
  key: DateTime
  connection: OrderHistoryConnection
}

type OrderHistoryConnectionUpdated_at {
  key: DateTime
  connection: OrderHistoryConnection
}

type OrderHistoryConnectionOrderName {
  key: String
  connection: OrderHistoryConnection
}

type OrderHistoryConnectionOrder {
  key: ID
  connection: OrderHistoryConnection
}

type OrderHistoryConnectionPayment_status {
  key: String
  connection: OrderHistoryConnection
}

type OrderHistoryConnectionPublished_at {
  key: DateTime
  connection: OrderHistoryConnection
}

input OrderHistoryInput {
  OrderName: String
  order: ID
  order_statuses: [ID]
  payment_status: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editOrderHistoryInput {
  OrderName: String
  order: ID
  order_statuses: [ID]
  payment_status: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createOrderHistoryInput {
  data: OrderHistoryInput
}

type createOrderHistoryPayload {
  orderHistory: OrderHistory
}

input updateOrderHistoryInput {
  where: InputID
  data: editOrderHistoryInput
}

type updateOrderHistoryPayload {
  orderHistory: OrderHistory
}

input deleteOrderHistoryInput {
  where: InputID
}

type deleteOrderHistoryPayload {
  orderHistory: OrderHistory
}

type OrderStatus {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  IsActive: Boolean
  published_at: DateTime
}

type OrderStatusConnection {
  values: [OrderStatus]
  groupBy: OrderStatusGroupBy
  aggregate: OrderStatusAggregator
}

type OrderStatusAggregator {
  count: Int
  totalCount: Int
}

type OrderStatusGroupBy {
  id: [OrderStatusConnectionId]
  created_at: [OrderStatusConnectionCreated_at]
  updated_at: [OrderStatusConnectionUpdated_at]
  Name: [OrderStatusConnectionName]
  IsActive: [OrderStatusConnectionIsActive]
  published_at: [OrderStatusConnectionPublished_at]
}

type OrderStatusConnectionId {
  key: ID
  connection: OrderStatusConnection
}

type OrderStatusConnectionCreated_at {
  key: DateTime
  connection: OrderStatusConnection
}

type OrderStatusConnectionUpdated_at {
  key: DateTime
  connection: OrderStatusConnection
}

type OrderStatusConnectionName {
  key: String
  connection: OrderStatusConnection
}

type OrderStatusConnectionIsActive {
  key: Boolean
  connection: OrderStatusConnection
}

type OrderStatusConnectionPublished_at {
  key: DateTime
  connection: OrderStatusConnection
}

input OrderStatusInput {
  Name: String
  IsActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editOrderStatusInput {
  Name: String
  IsActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createOrderStatusInput {
  data: OrderStatusInput
}

type createOrderStatusPayload {
  orderStatus: OrderStatus
}

input updateOrderStatusInput {
  where: InputID
  data: editOrderStatusInput
}

type updateOrderStatusPayload {
  orderStatus: OrderStatus
}

input deleteOrderStatusInput {
  where: InputID
}

type deleteOrderStatusPayload {
  orderStatus: OrderStatus
}

type Order {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  store: Store
  customer: UsersPermissionsUser
  delivery_date: DateTime
  name: String
  Weekly_needed: Boolean
  total_amount: Float
  disocunt: Float
  discount_code: String
  quantity: Long
  published_at: DateTime
  deliver_types(sort: String, limit: Int, start: Int, where: JSON): [DeliverType]
  order_details(sort: String, limit: Int, start: Int, where: JSON): [OrderDetail]
  order_statuses(sort: String, limit: Int, start: Int, where: JSON): [OrderStatus]
  order_histories(sort: String, limit: Int, start: Int, where: JSON): [OrderHistory]
}

type OrderConnection {
  values: [Order]
  groupBy: OrderGroupBy
  aggregate: OrderAggregator
}

type OrderAggregator {
  count: Int
  totalCount: Int
  sum: OrderAggregatorSum
  avg: OrderAggregatorAvg
  min: OrderAggregatorMin
  max: OrderAggregatorMax
}

type OrderAggregatorSum {
  total_amount: Float
  disocunt: Float
}

type OrderAggregatorAvg {
  total_amount: Float
  disocunt: Float
}

type OrderAggregatorMin {
  total_amount: Float
  disocunt: Float
}

type OrderAggregatorMax {
  total_amount: Float
  disocunt: Float
}

type OrderGroupBy {
  id: [OrderConnectionId]
  created_at: [OrderConnectionCreated_at]
  updated_at: [OrderConnectionUpdated_at]
  store: [OrderConnectionStore]
  customer: [OrderConnectionCustomer]
  delivery_date: [OrderConnectionDelivery_date]
  name: [OrderConnectionName]
  Weekly_needed: [OrderConnectionWeekly_needed]
  total_amount: [OrderConnectionTotal_amount]
  disocunt: [OrderConnectionDisocunt]
  discount_code: [OrderConnectionDiscount_code]
  quantity: [OrderConnectionQuantity]
  published_at: [OrderConnectionPublished_at]
}

type OrderConnectionId {
  key: ID
  connection: OrderConnection
}

type OrderConnectionCreated_at {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionUpdated_at {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionStore {
  key: ID
  connection: OrderConnection
}

type OrderConnectionCustomer {
  key: ID
  connection: OrderConnection
}

type OrderConnectionDelivery_date {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionName {
  key: String
  connection: OrderConnection
}

type OrderConnectionWeekly_needed {
  key: Boolean
  connection: OrderConnection
}

type OrderConnectionTotal_amount {
  key: Float
  connection: OrderConnection
}

type OrderConnectionDisocunt {
  key: Float
  connection: OrderConnection
}

type OrderConnectionDiscount_code {
  key: String
  connection: OrderConnection
}

type OrderConnectionQuantity {
  key: ID
  connection: OrderConnection
}

type OrderConnectionPublished_at {
  key: DateTime
  connection: OrderConnection
}

input OrderInput {
  store: ID
  customer: ID
  delivery_date: DateTime
  name: String
  deliver_types: [ID]
  Weekly_needed: Boolean
  total_amount: Float
  disocunt: Float
  order_details: [ID]
  discount_code: String
  quantity: Long
  order_statuses: [ID]
  order_histories: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editOrderInput {
  store: ID
  customer: ID
  delivery_date: DateTime
  name: String
  deliver_types: [ID]
  Weekly_needed: Boolean
  total_amount: Float
  disocunt: Float
  order_details: [ID]
  discount_code: String
  quantity: Long
  order_statuses: [ID]
  order_histories: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createOrderInput {
  data: OrderInput
}

type createOrderPayload {
  order: Order
}

input updateOrderInput {
  where: InputID
  data: editOrderInput
}

type updateOrderPayload {
  order: Order
}

input deleteOrderInput {
  where: InputID
}

type deleteOrderPayload {
  order: Order
}

type Packinging {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  isActive: Boolean
  published_at: DateTime
}

type PackingingConnection {
  values: [Packinging]
  groupBy: PackingingGroupBy
  aggregate: PackingingAggregator
}

type PackingingAggregator {
  count: Int
  totalCount: Int
}

type PackingingGroupBy {
  id: [PackingingConnectionId]
  created_at: [PackingingConnectionCreated_at]
  updated_at: [PackingingConnectionUpdated_at]
  name: [PackingingConnectionName]
  isActive: [PackingingConnectionIsActive]
  published_at: [PackingingConnectionPublished_at]
}

type PackingingConnectionId {
  key: ID
  connection: PackingingConnection
}

type PackingingConnectionCreated_at {
  key: DateTime
  connection: PackingingConnection
}

type PackingingConnectionUpdated_at {
  key: DateTime
  connection: PackingingConnection
}

type PackingingConnectionName {
  key: String
  connection: PackingingConnection
}

type PackingingConnectionIsActive {
  key: Boolean
  connection: PackingingConnection
}

type PackingingConnectionPublished_at {
  key: DateTime
  connection: PackingingConnection
}

input PackingingInput {
  name: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPackingingInput {
  name: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPackingingInput {
  data: PackingingInput
}

type createPackingingPayload {
  packinging: Packinging
}

input updatePackingingInput {
  where: InputID
  data: editPackingingInput
}

type updatePackingingPayload {
  packinging: Packinging
}

input deletePackingingInput {
  where: InputID
}

type deletePackingingPayload {
  packinging: Packinging
}

type PreferredCategory {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  IsActive: Boolean
  store: Store
  published_at: DateTime
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type PreferredCategoryConnection {
  values: [PreferredCategory]
  groupBy: PreferredCategoryGroupBy
  aggregate: PreferredCategoryAggregator
}

type PreferredCategoryAggregator {
  count: Int
  totalCount: Int
}

type PreferredCategoryGroupBy {
  id: [PreferredCategoryConnectionId]
  created_at: [PreferredCategoryConnectionCreated_at]
  updated_at: [PreferredCategoryConnectionUpdated_at]
  Name: [PreferredCategoryConnectionName]
  IsActive: [PreferredCategoryConnectionIsActive]
  store: [PreferredCategoryConnectionStore]
  published_at: [PreferredCategoryConnectionPublished_at]
}

type PreferredCategoryConnectionId {
  key: ID
  connection: PreferredCategoryConnection
}

type PreferredCategoryConnectionCreated_at {
  key: DateTime
  connection: PreferredCategoryConnection
}

type PreferredCategoryConnectionUpdated_at {
  key: DateTime
  connection: PreferredCategoryConnection
}

type PreferredCategoryConnectionName {
  key: String
  connection: PreferredCategoryConnection
}

type PreferredCategoryConnectionIsActive {
  key: Boolean
  connection: PreferredCategoryConnection
}

type PreferredCategoryConnectionStore {
  key: ID
  connection: PreferredCategoryConnection
}

type PreferredCategoryConnectionPublished_at {
  key: DateTime
  connection: PreferredCategoryConnection
}

input PreferredCategoryInput {
  Name: String
  IsActive: Boolean
  store: ID
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPreferredCategoryInput {
  Name: String
  IsActive: Boolean
  store: ID
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPreferredCategoryInput {
  data: PreferredCategoryInput
}

type createPreferredCategoryPayload {
  preferredCategory: PreferredCategory
}

input updatePreferredCategoryInput {
  where: InputID
  data: editPreferredCategoryInput
}

type updatePreferredCategoryPayload {
  preferredCategory: PreferredCategory
}

input deletePreferredCategoryInput {
  where: InputID
}

type deletePreferredCategoryPayload {
  preferredCategory: PreferredCategory
}

type ProductImage {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Image: UploadFile
  published_at: DateTime
  image2(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  image3(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  video1(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  video2(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type ProductImageConnection {
  values: [ProductImage]
  groupBy: ProductImageGroupBy
  aggregate: ProductImageAggregator
}

type ProductImageAggregator {
  count: Int
  totalCount: Int
}

type ProductImageGroupBy {
  id: [ProductImageConnectionId]
  created_at: [ProductImageConnectionCreated_at]
  updated_at: [ProductImageConnectionUpdated_at]
  Image: [ProductImageConnectionImage]
  published_at: [ProductImageConnectionPublished_at]
}

type ProductImageConnectionId {
  key: ID
  connection: ProductImageConnection
}

type ProductImageConnectionCreated_at {
  key: DateTime
  connection: ProductImageConnection
}

type ProductImageConnectionUpdated_at {
  key: DateTime
  connection: ProductImageConnection
}

type ProductImageConnectionImage {
  key: ID
  connection: ProductImageConnection
}

type ProductImageConnectionPublished_at {
  key: DateTime
  connection: ProductImageConnection
}

input ProductImageInput {
  Image: ID
  image2: [ID]
  image3: [ID]
  video1: [ID]
  video2: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductImageInput {
  Image: ID
  image2: [ID]
  image3: [ID]
  video1: [ID]
  video2: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductImageInput {
  data: ProductImageInput
}

type createProductImagePayload {
  productImage: ProductImage
}

input updateProductImageInput {
  where: InputID
  data: editProductImageInput
}

type updateProductImagePayload {
  productImage: ProductImage
}

input deleteProductImageInput {
  where: InputID
}

type deleteProductImagePayload {
  productImage: ProductImage
}

type ProductProperties {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  category: String
  isActive: Boolean
  store: Store
  published_at: DateTime
}

type ProductPropertiesConnection {
  values: [ProductProperties]
  groupBy: ProductPropertiesGroupBy
  aggregate: ProductPropertiesAggregator
}

type ProductPropertiesAggregator {
  count: Int
  totalCount: Int
}

type ProductPropertiesGroupBy {
  id: [ProductPropertiesConnectionId]
  created_at: [ProductPropertiesConnectionCreated_at]
  updated_at: [ProductPropertiesConnectionUpdated_at]
  name: [ProductPropertiesConnectionName]
  category: [ProductPropertiesConnectionCategory]
  isActive: [ProductPropertiesConnectionIsActive]
  store: [ProductPropertiesConnectionStore]
  published_at: [ProductPropertiesConnectionPublished_at]
}

type ProductPropertiesConnectionId {
  key: ID
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionCreated_at {
  key: DateTime
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionUpdated_at {
  key: DateTime
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionName {
  key: String
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionCategory {
  key: String
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionIsActive {
  key: Boolean
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionStore {
  key: ID
  connection: ProductPropertiesConnection
}

type ProductPropertiesConnectionPublished_at {
  key: DateTime
  connection: ProductPropertiesConnection
}

input ProductPropertyInput {
  name: String
  category: String
  isActive: Boolean
  store: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductPropertyInput {
  name: String
  category: String
  isActive: Boolean
  store: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductPropertyInput {
  data: ProductPropertyInput
}

type createProductPropertyPayload {
  productProperty: ProductProperties
}

input updateProductPropertyInput {
  where: InputID
  data: editProductPropertyInput
}

type updateProductPropertyPayload {
  productProperty: ProductProperties
}

input deleteProductPropertyInput {
  where: InputID
}

type deleteProductPropertyPayload {
  productProperty: ProductProperties
}

type ProductSize {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  isActive: Boolean
  price: Float
  discount_type: String
  discount: Float
  published_at: DateTime
  promotions(sort: String, limit: Int, start: Int, where: JSON): [Promotions]
}

type ProductSizeConnection {
  values: [ProductSize]
  groupBy: ProductSizeGroupBy
  aggregate: ProductSizeAggregator
}

type ProductSizeAggregator {
  count: Int
  totalCount: Int
  sum: ProductSizeAggregatorSum
  avg: ProductSizeAggregatorAvg
  min: ProductSizeAggregatorMin
  max: ProductSizeAggregatorMax
}

type ProductSizeAggregatorSum {
  price: Float
  discount: Float
}

type ProductSizeAggregatorAvg {
  price: Float
  discount: Float
}

type ProductSizeAggregatorMin {
  price: Float
  discount: Float
}

type ProductSizeAggregatorMax {
  price: Float
  discount: Float
}

type ProductSizeGroupBy {
  id: [ProductSizeConnectionId]
  created_at: [ProductSizeConnectionCreated_at]
  updated_at: [ProductSizeConnectionUpdated_at]
  name: [ProductSizeConnectionName]
  isActive: [ProductSizeConnectionIsActive]
  price: [ProductSizeConnectionPrice]
  discount_type: [ProductSizeConnectionDiscount_type]
  discount: [ProductSizeConnectionDiscount]
  published_at: [ProductSizeConnectionPublished_at]
}

type ProductSizeConnectionId {
  key: ID
  connection: ProductSizeConnection
}

type ProductSizeConnectionCreated_at {
  key: DateTime
  connection: ProductSizeConnection
}

type ProductSizeConnectionUpdated_at {
  key: DateTime
  connection: ProductSizeConnection
}

type ProductSizeConnectionName {
  key: String
  connection: ProductSizeConnection
}

type ProductSizeConnectionIsActive {
  key: Boolean
  connection: ProductSizeConnection
}

type ProductSizeConnectionPrice {
  key: Float
  connection: ProductSizeConnection
}

type ProductSizeConnectionDiscount_type {
  key: String
  connection: ProductSizeConnection
}

type ProductSizeConnectionDiscount {
  key: Float
  connection: ProductSizeConnection
}

type ProductSizeConnectionPublished_at {
  key: DateTime
  connection: ProductSizeConnection
}

input ProductSizeInput {
  name: String
  isActive: Boolean
  price: Float
  discount_type: String
  discount: Float
  promotions: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductSizeInput {
  name: String
  isActive: Boolean
  price: Float
  discount_type: String
  discount: Float
  promotions: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductSizeInput {
  data: ProductSizeInput
}

type createProductSizePayload {
  productSize: ProductSize
}

input updateProductSizeInput {
  where: InputID
  data: editProductSizeInput
}

type updateProductSizePayload {
  productSize: ProductSize
}

input deleteProductSizeInput {
  where: InputID
}

type deleteProductSizePayload {
  productSize: ProductSize
}

type ProductType {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  isActive: Boolean
  store: Store
  published_at: DateTime
}

type ProductTypeConnection {
  values: [ProductType]
  groupBy: ProductTypeGroupBy
  aggregate: ProductTypeAggregator
}

type ProductTypeAggregator {
  count: Int
  totalCount: Int
}

type ProductTypeGroupBy {
  id: [ProductTypeConnectionId]
  created_at: [ProductTypeConnectionCreated_at]
  updated_at: [ProductTypeConnectionUpdated_at]
  name: [ProductTypeConnectionName]
  isActive: [ProductTypeConnectionIsActive]
  store: [ProductTypeConnectionStore]
  published_at: [ProductTypeConnectionPublished_at]
}

type ProductTypeConnectionId {
  key: ID
  connection: ProductTypeConnection
}

type ProductTypeConnectionCreated_at {
  key: DateTime
  connection: ProductTypeConnection
}

type ProductTypeConnectionUpdated_at {
  key: DateTime
  connection: ProductTypeConnection
}

type ProductTypeConnectionName {
  key: String
  connection: ProductTypeConnection
}

type ProductTypeConnectionIsActive {
  key: Boolean
  connection: ProductTypeConnection
}

type ProductTypeConnectionStore {
  key: ID
  connection: ProductTypeConnection
}

type ProductTypeConnectionPublished_at {
  key: DateTime
  connection: ProductTypeConnection
}

input ProductTypeInput {
  name: String
  isActive: Boolean
  store: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductTypeInput {
  name: String
  isActive: Boolean
  store: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductTypeInput {
  data: ProductTypeInput
}

type createProductTypePayload {
  productType: ProductType
}

input updateProductTypeInput {
  where: InputID
  data: editProductTypeInput
}

type updateProductTypePayload {
  productType: ProductType
}

input deleteProductTypeInput {
  where: InputID
}

type deleteProductTypePayload {
  productType: ProductType
}

type Product {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  productName: String
  description: String
  isActive: Boolean
  Price: Float!
  createdDate: DateTime
  createdBy: String
  orderDetail: OrderDetail
  itemCode: String
  ingredients: String
  allergen: String
  productimagee: UploadFile
  published_at: DateTime
  stores(sort: String, limit: Int, start: Int, where: JSON): [Store]
  productCategories(sort: String, limit: Int, start: Int, where: JSON): [MenuCategory]
  preferredCategories(sort: String, limit: Int, start: Int, where: JSON): [PreferredCategory]
  productProperty1(sort: String, limit: Int, start: Int, where: JSON): [ProductProperties]
  delivery_days(sort: String, limit: Int, start: Int, where: JSON): [DeliveryDays]
}

type ProductConnection {
  values: [Product]
  groupBy: ProductGroupBy
  aggregate: ProductAggregator
}

type ProductAggregator {
  count: Int
  totalCount: Int
  sum: ProductAggregatorSum
  avg: ProductAggregatorAvg
  min: ProductAggregatorMin
  max: ProductAggregatorMax
}

type ProductAggregatorSum {
  Price: Float
}

type ProductAggregatorAvg {
  Price: Float
}

type ProductAggregatorMin {
  Price: Float
}

type ProductAggregatorMax {
  Price: Float
}

type ProductGroupBy {
  id: [ProductConnectionId]
  created_at: [ProductConnectionCreated_at]
  updated_at: [ProductConnectionUpdated_at]
  productName: [ProductConnectionProductName]
  description: [ProductConnectionDescription]
  isActive: [ProductConnectionIsActive]
  Price: [ProductConnectionPrice]
  createdDate: [ProductConnectionCreatedDate]
  createdBy: [ProductConnectionCreatedBy]
  orderDetail: [ProductConnectionOrderDetail]
  itemCode: [ProductConnectionItemCode]
  ingredients: [ProductConnectionIngredients]
  allergen: [ProductConnectionAllergen]
  productimagee: [ProductConnectionProductimagee]
  published_at: [ProductConnectionPublished_at]
}

type ProductConnectionId {
  key: ID
  connection: ProductConnection
}

type ProductConnectionCreated_at {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionUpdated_at {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionProductName {
  key: String
  connection: ProductConnection
}

type ProductConnectionDescription {
  key: String
  connection: ProductConnection
}

type ProductConnectionIsActive {
  key: Boolean
  connection: ProductConnection
}

type ProductConnectionPrice {
  key: Float
  connection: ProductConnection
}

type ProductConnectionCreatedDate {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionCreatedBy {
  key: String
  connection: ProductConnection
}

type ProductConnectionOrderDetail {
  key: ID
  connection: ProductConnection
}

type ProductConnectionItemCode {
  key: String
  connection: ProductConnection
}

type ProductConnectionIngredients {
  key: String
  connection: ProductConnection
}

type ProductConnectionAllergen {
  key: String
  connection: ProductConnection
}

type ProductConnectionProductimagee {
  key: ID
  connection: ProductConnection
}

type ProductConnectionPublished_at {
  key: DateTime
  connection: ProductConnection
}

input ProductInput {
  productName: String
  stores: [ID]
  description: String
  isActive: Boolean
  productCategories: [ID]
  Price: Float!
  preferredCategories: [ID]
  createdDate: DateTime
  createdBy: String
  orderDetail: ID
  itemCode: String
  productProperty1: [ID]
  delivery_days: [ID]
  ingredients: String
  allergen: String
  productimagee: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductInput {
  productName: String
  stores: [ID]
  description: String
  isActive: Boolean
  productCategories: [ID]
  Price: Float
  preferredCategories: [ID]
  createdDate: DateTime
  createdBy: String
  orderDetail: ID
  itemCode: String
  productProperty1: [ID]
  delivery_days: [ID]
  ingredients: String
  allergen: String
  productimagee: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Product
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Product
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Product
}

type PromotionDetail {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  free_product: Boolean
  product_name: String
  published_at: DateTime
  promotions(sort: String, limit: Int, start: Int, where: JSON): [Promotions]
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type PromotionDetailConnection {
  values: [PromotionDetail]
  groupBy: PromotionDetailGroupBy
  aggregate: PromotionDetailAggregator
}

type PromotionDetailAggregator {
  count: Int
  totalCount: Int
}

type PromotionDetailGroupBy {
  id: [PromotionDetailConnectionId]
  created_at: [PromotionDetailConnectionCreated_at]
  updated_at: [PromotionDetailConnectionUpdated_at]
  free_product: [PromotionDetailConnectionFree_product]
  product_name: [PromotionDetailConnectionProduct_name]
  published_at: [PromotionDetailConnectionPublished_at]
}

type PromotionDetailConnectionId {
  key: ID
  connection: PromotionDetailConnection
}

type PromotionDetailConnectionCreated_at {
  key: DateTime
  connection: PromotionDetailConnection
}

type PromotionDetailConnectionUpdated_at {
  key: DateTime
  connection: PromotionDetailConnection
}

type PromotionDetailConnectionFree_product {
  key: Boolean
  connection: PromotionDetailConnection
}

type PromotionDetailConnectionProduct_name {
  key: String
  connection: PromotionDetailConnection
}

type PromotionDetailConnectionPublished_at {
  key: DateTime
  connection: PromotionDetailConnection
}

input PromotionDetailInput {
  free_product: Boolean
  promotions: [ID]
  products: [ID]
  product_name: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPromotionDetailInput {
  free_product: Boolean
  promotions: [ID]
  products: [ID]
  product_name: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPromotionDetailInput {
  data: PromotionDetailInput
}

type createPromotionDetailPayload {
  promotionDetail: PromotionDetail
}

input updatePromotionDetailInput {
  where: InputID
  data: editPromotionDetailInput
}

type updatePromotionDetailPayload {
  promotionDetail: PromotionDetail
}

input deletePromotionDetailInput {
  where: InputID
}

type deletePromotionDetailPayload {
  promotionDetail: PromotionDetail
}

type Promotions {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  offerimage: UploadFile
  isActive: Boolean
  product_category: MenuCategory
  description: String
  discount_type: String
  published_at: DateTime
  stores(sort: String, limit: Int, start: Int, where: JSON): [Store]
  delivery_days(sort: String, limit: Int, start: Int, where: JSON): [DeliveryDays]
  promotion_types(sort: String, limit: Int, start: Int, where: JSON): [ProductType]
  packingings(sort: String, limit: Int, start: Int, where: JSON): [Packinging]
  product_properties(sort: String, limit: Int, start: Int, where: JSON): [ProductProperties]
  OfferImage(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  OfferVIdeo(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  product_size_price(sort: String, limit: Int, start: Int, where: JSON): [ProductSize]
  promotion_details(sort: String, limit: Int, start: Int, where: JSON): [PromotionDetail]
}

type PromotionsConnection {
  values: [Promotions]
  groupBy: PromotionsGroupBy
  aggregate: PromotionsAggregator
}

type PromotionsAggregator {
  count: Int
  totalCount: Int
}

type PromotionsGroupBy {
  id: [PromotionsConnectionId]
  created_at: [PromotionsConnectionCreated_at]
  updated_at: [PromotionsConnectionUpdated_at]
  name: [PromotionsConnectionName]
  offerimage: [PromotionsConnectionOfferimage]
  isActive: [PromotionsConnectionIsActive]
  product_category: [PromotionsConnectionProduct_category]
  description: [PromotionsConnectionDescription]
  discount_type: [PromotionsConnectionDiscount_type]
  published_at: [PromotionsConnectionPublished_at]
}

type PromotionsConnectionId {
  key: ID
  connection: PromotionsConnection
}

type PromotionsConnectionCreated_at {
  key: DateTime
  connection: PromotionsConnection
}

type PromotionsConnectionUpdated_at {
  key: DateTime
  connection: PromotionsConnection
}

type PromotionsConnectionName {
  key: String
  connection: PromotionsConnection
}

type PromotionsConnectionOfferimage {
  key: ID
  connection: PromotionsConnection
}

type PromotionsConnectionIsActive {
  key: Boolean
  connection: PromotionsConnection
}

type PromotionsConnectionProduct_category {
  key: ID
  connection: PromotionsConnection
}

type PromotionsConnectionDescription {
  key: String
  connection: PromotionsConnection
}

type PromotionsConnectionDiscount_type {
  key: String
  connection: PromotionsConnection
}

type PromotionsConnectionPublished_at {
  key: DateTime
  connection: PromotionsConnection
}

input PromotionInput {
  name: String
  offerimage: ID
  isActive: Boolean
  stores: [ID]
  delivery_days: [ID]
  product_category: ID
  promotion_types: [ID]
  packingings: [ID]
  product_properties: [ID]
  OfferImage: [ID]
  OfferVIdeo: [ID]
  description: String
  discount_type: String
  product_size_price: [ID]
  promotion_details: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPromotionInput {
  name: String
  offerimage: ID
  isActive: Boolean
  stores: [ID]
  delivery_days: [ID]
  product_category: ID
  promotion_types: [ID]
  packingings: [ID]
  product_properties: [ID]
  OfferImage: [ID]
  OfferVIdeo: [ID]
  description: String
  discount_type: String
  product_size_price: [ID]
  promotion_details: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPromotionInput {
  data: PromotionInput
}

type createPromotionPayload {
  promotion: Promotions
}

input updatePromotionInput {
  where: InputID
  data: editPromotionInput
}

type updatePromotionPayload {
  promotion: Promotions
}

input deletePromotionInput {
  where: InputID
}

type deletePromotionPayload {
  promotion: Promotions
}

type Reviews {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  customerReviews: String
  rating: String
  isActive: Boolean
  vendorAnswer: String
  usersPermissionsUser: UsersPermissionsUser
  store: Store
  published_at: DateTime
}

type ReviewsConnection {
  values: [Reviews]
  groupBy: ReviewsGroupBy
  aggregate: ReviewsAggregator
}

type ReviewsAggregator {
  count: Int
  totalCount: Int
}

type ReviewsGroupBy {
  id: [ReviewsConnectionId]
  created_at: [ReviewsConnectionCreated_at]
  updated_at: [ReviewsConnectionUpdated_at]
  customerReviews: [ReviewsConnectionCustomerReviews]
  rating: [ReviewsConnectionRating]
  isActive: [ReviewsConnectionIsActive]
  vendorAnswer: [ReviewsConnectionVendorAnswer]
  usersPermissionsUser: [ReviewsConnectionUsersPermissionsUser]
  store: [ReviewsConnectionStore]
  published_at: [ReviewsConnectionPublished_at]
}

type ReviewsConnectionId {
  key: ID
  connection: ReviewsConnection
}

type ReviewsConnectionCreated_at {
  key: DateTime
  connection: ReviewsConnection
}

type ReviewsConnectionUpdated_at {
  key: DateTime
  connection: ReviewsConnection
}

type ReviewsConnectionCustomerReviews {
  key: String
  connection: ReviewsConnection
}

type ReviewsConnectionRating {
  key: String
  connection: ReviewsConnection
}

type ReviewsConnectionIsActive {
  key: Boolean
  connection: ReviewsConnection
}

type ReviewsConnectionVendorAnswer {
  key: String
  connection: ReviewsConnection
}

type ReviewsConnectionUsersPermissionsUser {
  key: ID
  connection: ReviewsConnection
}

type ReviewsConnectionStore {
  key: ID
  connection: ReviewsConnection
}

type ReviewsConnectionPublished_at {
  key: DateTime
  connection: ReviewsConnection
}

input ReviewInput {
  customerReviews: String
  rating: String
  isActive: Boolean
  vendorAnswer: String
  usersPermissionsUser: ID
  store: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editReviewInput {
  customerReviews: String
  rating: String
  isActive: Boolean
  vendorAnswer: String
  usersPermissionsUser: ID
  store: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createReviewInput {
  data: ReviewInput
}

type createReviewPayload {
  review: Reviews
}

input updateReviewInput {
  where: InputID
  data: editReviewInput
}

type updateReviewPayload {
  review: Reviews
}

input deleteReviewInput {
  where: InputID
}

type deleteReviewPayload {
  review: Reviews
}

type Settings {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  settingName: String
  settingValue: String
  isActive: Boolean
  published_at: DateTime
}

type SettingsConnection {
  values: [Settings]
  groupBy: SettingsGroupBy
  aggregate: SettingsAggregator
}

type SettingsAggregator {
  count: Int
  totalCount: Int
}

type SettingsGroupBy {
  id: [SettingsConnectionId]
  created_at: [SettingsConnectionCreated_at]
  updated_at: [SettingsConnectionUpdated_at]
  settingName: [SettingsConnectionSettingName]
  settingValue: [SettingsConnectionSettingValue]
  isActive: [SettingsConnectionIsActive]
  published_at: [SettingsConnectionPublished_at]
}

type SettingsConnectionId {
  key: ID
  connection: SettingsConnection
}

type SettingsConnectionCreated_at {
  key: DateTime
  connection: SettingsConnection
}

type SettingsConnectionUpdated_at {
  key: DateTime
  connection: SettingsConnection
}

type SettingsConnectionSettingName {
  key: String
  connection: SettingsConnection
}

type SettingsConnectionSettingValue {
  key: String
  connection: SettingsConnection
}

type SettingsConnectionIsActive {
  key: Boolean
  connection: SettingsConnection
}

type SettingsConnectionPublished_at {
  key: DateTime
  connection: SettingsConnection
}

input SettingInput {
  settingName: String
  settingValue: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSettingInput {
  settingName: String
  settingValue: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createSettingInput {
  data: SettingInput
}

type createSettingPayload {
  setting: Settings
}

input updateSettingInput {
  where: InputID
  data: editSettingInput
}

type updateSettingPayload {
  setting: Settings
}

input deleteSettingInput {
  where: InputID
}

type deleteSettingPayload {
  setting: Settings
}

type State {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  stateName: String!
  isActive: Boolean!
  published_at: DateTime
}

type StateConnection {
  values: [State]
  groupBy: StateGroupBy
  aggregate: StateAggregator
}

type StateAggregator {
  count: Int
  totalCount: Int
}

type StateGroupBy {
  id: [StateConnectionId]
  created_at: [StateConnectionCreated_at]
  updated_at: [StateConnectionUpdated_at]
  stateName: [StateConnectionStateName]
  isActive: [StateConnectionIsActive]
  published_at: [StateConnectionPublished_at]
}

type StateConnectionId {
  key: ID
  connection: StateConnection
}

type StateConnectionCreated_at {
  key: DateTime
  connection: StateConnection
}

type StateConnectionUpdated_at {
  key: DateTime
  connection: StateConnection
}

type StateConnectionStateName {
  key: String
  connection: StateConnection
}

type StateConnectionIsActive {
  key: Boolean
  connection: StateConnection
}

type StateConnectionPublished_at {
  key: DateTime
  connection: StateConnection
}

input StateInput {
  stateName: String!
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editStateInput {
  stateName: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createStateInput {
  data: StateInput
}

type createStatePayload {
  state: State
}

input updateStateInput {
  where: InputID
  data: editStateInput
}

type updateStatePayload {
  state: State
}

input deleteStateInput {
  where: InputID
}

type deleteStatePayload {
  state: State
}

type Store {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  StoreName: String
  users_permissions_user: UsersPermissionsUser
  Image: UploadFile
  self_delivery: Boolean
  longitude: Float
  Latitude: Float
  Storeopen: Time
  StoreClose: Time
  allergen: String
  commission: Commission
  delivery_distance: Float
  cooking_experience: String
  secondaryContact: String
  published_at: DateTime
  delivers_area(sort: String, limit: Int, start: Int, where: JSON): [Delivers]
  preferred_categories(sort: String, limit: Int, start: Int, where: JSON): [PreferredCategory]
  menu_categories(sort: String, limit: Int, start: Int, where: JSON): [MenuCategory]
  reviews(sort: String, limit: Int, start: Int, where: JSON): [Reviews]
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
  deliver_types(sort: String, limit: Int, start: Int, where: JSON): [DeliverType]
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
  delivery_days(sort: String, limit: Int, start: Int, where: JSON): [DeliveryDays]
  promotions(sort: String, limit: Int, start: Int, where: JSON): [Promotions]
  promotion_types(sort: String, limit: Int, start: Int, where: JSON): [ProductType]
  product_properties(sort: String, limit: Int, start: Int, where: JSON): [ProductProperties]
}

type StoreConnection {
  values: [Store]
  groupBy: StoreGroupBy
  aggregate: StoreAggregator
}

type StoreAggregator {
  count: Int
  totalCount: Int
  sum: StoreAggregatorSum
  avg: StoreAggregatorAvg
  min: StoreAggregatorMin
  max: StoreAggregatorMax
}

type StoreAggregatorSum {
  longitude: Float
  Latitude: Float
  delivery_distance: Float
}

type StoreAggregatorAvg {
  longitude: Float
  Latitude: Float
  delivery_distance: Float
}

type StoreAggregatorMin {
  longitude: Float
  Latitude: Float
  delivery_distance: Float
}

type StoreAggregatorMax {
  longitude: Float
  Latitude: Float
  delivery_distance: Float
}

type StoreGroupBy {
  id: [StoreConnectionId]
  created_at: [StoreConnectionCreated_at]
  updated_at: [StoreConnectionUpdated_at]
  StoreName: [StoreConnectionStoreName]
  users_permissions_user: [StoreConnectionUsers_permissions_user]
  Image: [StoreConnectionImage]
  self_delivery: [StoreConnectionSelf_delivery]
  longitude: [StoreConnectionLongitude]
  Latitude: [StoreConnectionLatitude]
  Storeopen: [StoreConnectionStoreopen]
  StoreClose: [StoreConnectionStoreClose]
  allergen: [StoreConnectionAllergen]
  commission: [StoreConnectionCommission]
  delivery_distance: [StoreConnectionDelivery_distance]
  cooking_experience: [StoreConnectionCooking_experience]
  secondaryContact: [StoreConnectionSecondaryContact]
  published_at: [StoreConnectionPublished_at]
}

type StoreConnectionId {
  key: ID
  connection: StoreConnection
}

type StoreConnectionCreated_at {
  key: DateTime
  connection: StoreConnection
}

type StoreConnectionUpdated_at {
  key: DateTime
  connection: StoreConnection
}

type StoreConnectionStoreName {
  key: String
  connection: StoreConnection
}

type StoreConnectionUsers_permissions_user {
  key: ID
  connection: StoreConnection
}

type StoreConnectionImage {
  key: ID
  connection: StoreConnection
}

type StoreConnectionSelf_delivery {
  key: Boolean
  connection: StoreConnection
}

type StoreConnectionLongitude {
  key: Float
  connection: StoreConnection
}

type StoreConnectionLatitude {
  key: Float
  connection: StoreConnection
}

type StoreConnectionStoreopen {
  key: ID
  connection: StoreConnection
}

type StoreConnectionStoreClose {
  key: ID
  connection: StoreConnection
}

type StoreConnectionAllergen {
  key: String
  connection: StoreConnection
}

type StoreConnectionCommission {
  key: ID
  connection: StoreConnection
}

type StoreConnectionDelivery_distance {
  key: Float
  connection: StoreConnection
}

type StoreConnectionCooking_experience {
  key: String
  connection: StoreConnection
}

type StoreConnectionSecondaryContact {
  key: String
  connection: StoreConnection
}

type StoreConnectionPublished_at {
  key: DateTime
  connection: StoreConnection
}

input StoreInput {
  StoreName: String
  users_permissions_user: ID
  delivers_area: [ID]
  preferred_categories: [ID]
  menu_categories: [ID]
  reviews: [ID]
  Image: ID
  products: [ID]
  deliver_types: [ID]
  orders: [ID]
  self_delivery: Boolean
  delivery_days: [ID]
  longitude: Float
  Latitude: Float
  Storeopen: Time
  StoreClose: Time
  promotions: [ID]
  allergen: String
  promotion_types: [ID]
  product_properties: [ID]
  commission: ID
  delivery_distance: Float
  cooking_experience: String
  secondaryContact: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editStoreInput {
  StoreName: String
  users_permissions_user: ID
  delivers_area: [ID]
  preferred_categories: [ID]
  menu_categories: [ID]
  reviews: [ID]
  Image: ID
  products: [ID]
  deliver_types: [ID]
  orders: [ID]
  self_delivery: Boolean
  delivery_days: [ID]
  longitude: Float
  Latitude: Float
  Storeopen: Time
  StoreClose: Time
  promotions: [ID]
  allergen: String
  promotion_types: [ID]
  product_properties: [ID]
  commission: ID
  delivery_distance: Float
  cooking_experience: String
  secondaryContact: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createStoreInput {
  data: StoreInput
}

type createStorePayload {
  store: Store
}

input updateStoreInput {
  where: InputID
  data: editStoreInput
}

type updateStorePayload {
  store: Store
}

input deleteStoreInput {
  where: InputID
}

type deleteStorePayload {
  store: Store
}

type UserType {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  isActive: Boolean
  published_at: DateTime
}

type UserTypeConnection {
  values: [UserType]
  groupBy: UserTypeGroupBy
  aggregate: UserTypeAggregator
}

type UserTypeAggregator {
  count: Int
  totalCount: Int
}

type UserTypeGroupBy {
  id: [UserTypeConnectionId]
  created_at: [UserTypeConnectionCreated_at]
  updated_at: [UserTypeConnectionUpdated_at]
  name: [UserTypeConnectionName]
  isActive: [UserTypeConnectionIsActive]
  published_at: [UserTypeConnectionPublished_at]
}

type UserTypeConnectionId {
  key: ID
  connection: UserTypeConnection
}

type UserTypeConnectionCreated_at {
  key: DateTime
  connection: UserTypeConnection
}

type UserTypeConnectionUpdated_at {
  key: DateTime
  connection: UserTypeConnection
}

type UserTypeConnectionName {
  key: String
  connection: UserTypeConnection
}

type UserTypeConnectionIsActive {
  key: Boolean
  connection: UserTypeConnection
}

type UserTypeConnectionPublished_at {
  key: DateTime
  connection: UserTypeConnection
}

input UserTypeInput {
  name: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editUserTypeInput {
  name: String
  isActive: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createUserTypeInput {
  data: UserTypeInput
}

type createUserTypePayload {
  userType: UserType
}

input updateUserTypeInput {
  where: InputID
  data: editUserTypeInput
}

type updateUserTypePayload {
  userType: UserType
}

input deleteUserTypeInput {
  where: InputID
}

type deleteUserTypePayload {
  userType: UserType
}

type I18NLocale {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  code: String
}

input LocaleInput {
  name: String
  code: String
  created_by: ID
  updated_by: ID
}

input editLocaleInput {
  name: String
  code: String
  created_by: ID
  updated_by: ID
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  FirstName: String!
  lastName: String!
  DOB: String!
  ineracEmail: String
  vendorCode: String!
  userImage: UploadFile
  documentsRequired: Boolean
  store: Store
  catalogApprove: Boolean
  cellPhone: String
  Homephone: String
  homeStreet: String
  homeUnitNo: String
  homeCity: String
  homePostalCode: String
  homeProvince: String
  pickStreet: String
  pickUnitNo: String
  pickCity: String
  pickPostalCode: String
  pickProvince: String
  profileApproved: Boolean
  user_types(sort: String, limit: Int, start: Int, where: JSON): [UserType]
  addresses(sort: String, limit: Int, start: Int, where: JSON): [Address]
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  FirstName: [UsersPermissionsUserConnectionFirstName]
  lastName: [UsersPermissionsUserConnectionLastName]
  DOB: [UsersPermissionsUserConnectionDOB]
  ineracEmail: [UsersPermissionsUserConnectionIneracEmail]
  vendorCode: [UsersPermissionsUserConnectionVendorCode]
  userImage: [UsersPermissionsUserConnectionUserImage]
  documentsRequired: [UsersPermissionsUserConnectionDocumentsRequired]
  store: [UsersPermissionsUserConnectionStore]
  catalogApprove: [UsersPermissionsUserConnectionCatalogApprove]
  cellPhone: [UsersPermissionsUserConnectionCellPhone]
  Homephone: [UsersPermissionsUserConnectionHomephone]
  homeStreet: [UsersPermissionsUserConnectionHomeStreet]
  homeUnitNo: [UsersPermissionsUserConnectionHomeUnitNo]
  homeCity: [UsersPermissionsUserConnectionHomeCity]
  homePostalCode: [UsersPermissionsUserConnectionHomePostalCode]
  homeProvince: [UsersPermissionsUserConnectionHomeProvince]
  pickStreet: [UsersPermissionsUserConnectionPickStreet]
  pickUnitNo: [UsersPermissionsUserConnectionPickUnitNo]
  pickCity: [UsersPermissionsUserConnectionPickCity]
  pickPostalCode: [UsersPermissionsUserConnectionPickPostalCode]
  pickProvince: [UsersPermissionsUserConnectionPickProvince]
  profileApproved: [UsersPermissionsUserConnectionProfileApproved]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionFirstName {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionLastName {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionDOB {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionIneracEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionVendorCode {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUserImage {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionDocumentsRequired {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionStore {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCatalogApprove {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCellPhone {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionHomephone {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionHomeStreet {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionHomeUnitNo {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionHomeCity {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionHomePostalCode {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionHomeProvince {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionPickStreet {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionPickUnitNo {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionPickCity {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionPickPostalCode {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionPickProvince {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProfileApproved {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  FirstName: String!
  lastName: String!
  DOB: String!
  ineracEmail: String
  vendorCode: String!
  userImage: ID
  documentsRequired: Boolean
  user_types: [ID]
  store: ID
  addresses: [ID]
  orders: [ID]
  catalogApprove: Boolean
  cellPhone: String
  Homephone: String
  homeStreet: String
  homeUnitNo: String
  homeCity: String
  homePostalCode: String
  homeProvince: String
  pickStreet: String
  pickUnitNo: String
  pickCity: String
  pickPostalCode: String
  pickProvince: String
  profileApproved: Boolean
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  FirstName: String
  lastName: String
  DOB: String
  ineracEmail: String
  vendorCode: String
  userImage: ID
  documentsRequired: Boolean
  user_types: [ID]
  store: ID
  addresses: [ID]
  orders: [ID]
  catalogApprove: Boolean
  cellPhone: String
  Homephone: String
  homeStreet: String
  homeUnitNo: String
  homeCity: String
  homePostalCode: String
  homeProvince: String
  pickStreet: String
  pickUnitNo: String
  pickCity: String
  pickPostalCode: String
  pickProvince: String
  profileApproved: Boolean
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | AddressType | AddressTypeConnection | AddressTypeAggregator | AddressTypeGroupBy | AddressTypeConnectionId | AddressTypeConnectionCreated_at | AddressTypeConnectionUpdated_at | AddressTypeConnectionName | AddressTypeConnectionIsActive | AddressTypeConnectionPublished_at | createAddressTypePayload | updateAddressTypePayload | deleteAddressTypePayload | Address | AddressConnection | AddressAggregator | AddressGroupBy | AddressConnectionId | AddressConnectionCreated_at | AddressConnectionUpdated_at | AddressConnectionCity | AddressConnectionState | AddressConnectionCountry | AddressConnectionStreetaddress | AddressConnectionPublished_at | createAddressPayload | updateAddressPayload | deleteAddressPayload | City | CityConnection | CityAggregator | CityGroupBy | CityConnectionId | CityConnectionCreated_at | CityConnectionUpdated_at | CityConnectionCityName | CityConnectionIsActive | CityConnectionPublished_at | createCityPayload | updateCityPayload | deleteCityPayload | Commission | CommissionConnection | CommissionAggregator | CommissionAggregatorSum | CommissionAggregatorAvg | CommissionAggregatorMin | CommissionAggregatorMax | CommissionGroupBy | CommissionConnectionId | CommissionConnectionCreated_at | CommissionConnectionUpdated_at | CommissionConnectionName | CommissionConnectionStore | CommissionConnectionValue | CommissionConnectionType | createCommissionPayload | updateCommissionPayload | deleteCommissionPayload | Country | CountryConnection | CountryAggregator | CountryGroupBy | CountryConnectionId | CountryConnectionCreated_at | CountryConnectionUpdated_at | CountryConnectionCountryName | CountryConnectionIsActive | CountryConnectionPublished_at | createCountryPayload | updateCountryPayload | deleteCountryPayload | DeleveiryCharges | DeleveiryChargesConnection | DeleveiryChargesAggregator | DeleveiryChargesAggregatorSum | DeleveiryChargesAggregatorAvg | DeleveiryChargesAggregatorMin | DeleveiryChargesAggregatorMax | DeleveiryChargesGroupBy | DeleveiryChargesConnectionId | DeleveiryChargesConnectionCreated_at | DeleveiryChargesConnectionUpdated_at | DeleveiryChargesConnectionDistanceFrom | DeleveiryChargesConnectionDistanceTo | DeleveiryChargesConnectionRate | DeleveiryChargesConnectionPublished_at | createDeleveiryChargePayload | updateDeleveiryChargePayload | deleteDeleveiryChargePayload | DeliverType | DeliverTypeConnection | DeliverTypeAggregator | DeliverTypeGroupBy | DeliverTypeConnectionId | DeliverTypeConnectionCreated_at | DeliverTypeConnectionUpdated_at | DeliverTypeConnectionName | DeliverTypeConnectionIsActive | DeliverTypeConnectionPublished_at | createDeliverTypePayload | updateDeliverTypePayload | deleteDeliverTypePayload | Delivers | DeliversConnection | DeliversAggregator | DeliversGroupBy | DeliversConnectionId | DeliversConnectionCreated_at | DeliversConnectionUpdated_at | DeliversConnectionName | DeliversConnectionIsActive | DeliversConnectionPublished_at | createDeliverPayload | updateDeliverPayload | deleteDeliverPayload | DeliveryDays | DeliveryDaysConnection | DeliveryDaysAggregator | DeliveryDaysGroupBy | DeliveryDaysConnectionId | DeliveryDaysConnectionCreated_at | DeliveryDaysConnectionUpdated_at | DeliveryDaysConnectionDaysName | DeliveryDaysConnectionDaysId | DeliveryDaysConnectionIsActive | DeliveryDaysConnectionPublished_at | createDeliveryDayPayload | updateDeliveryDayPayload | deleteDeliveryDayPayload | MenuCategory | MenuCategoryConnection | MenuCategoryAggregator | MenuCategoryAggregatorSum | MenuCategoryAggregatorAvg | MenuCategoryAggregatorMin | MenuCategoryAggregatorMax | MenuCategoryGroupBy | MenuCategoryConnectionId | MenuCategoryConnectionCreated_at | MenuCategoryConnectionUpdated_at | MenuCategoryConnectionName | MenuCategoryConnectionIsActive | MenuCategoryConnectionIsDisplayable | MenuCategoryConnectionImage | MenuCategoryConnectionPrice | MenuCategoryConnectionPricey | MenuCategoryConnectionPublished_at | createMenuCategoryPayload | updateMenuCategoryPayload | deleteMenuCategoryPayload | OrderDetail | OrderDetailConnection | OrderDetailAggregator | OrderDetailGroupBy | OrderDetailConnectionId | OrderDetailConnectionCreated_at | OrderDetailConnectionUpdated_at | OrderDetailConnectionIsActive | OrderDetailConnectionIsOffer | OrderDetailConnectionAmount | OrderDetailConnectionPublished_at | createOrderDetailPayload | updateOrderDetailPayload | deleteOrderDetailPayload | OrderHistory | OrderHistoryConnection | OrderHistoryAggregator | OrderHistoryGroupBy | OrderHistoryConnectionId | OrderHistoryConnectionCreated_at | OrderHistoryConnectionUpdated_at | OrderHistoryConnectionOrderName | OrderHistoryConnectionOrder | OrderHistoryConnectionPayment_status | OrderHistoryConnectionPublished_at | createOrderHistoryPayload | updateOrderHistoryPayload | deleteOrderHistoryPayload | OrderStatus | OrderStatusConnection | OrderStatusAggregator | OrderStatusGroupBy | OrderStatusConnectionId | OrderStatusConnectionCreated_at | OrderStatusConnectionUpdated_at | OrderStatusConnectionName | OrderStatusConnectionIsActive | OrderStatusConnectionPublished_at | createOrderStatusPayload | updateOrderStatusPayload | deleteOrderStatusPayload | Order | OrderConnection | OrderAggregator | OrderAggregatorSum | OrderAggregatorAvg | OrderAggregatorMin | OrderAggregatorMax | OrderGroupBy | OrderConnectionId | OrderConnectionCreated_at | OrderConnectionUpdated_at | OrderConnectionStore | OrderConnectionCustomer | OrderConnectionDelivery_date | OrderConnectionName | OrderConnectionWeekly_needed | OrderConnectionTotal_amount | OrderConnectionDisocunt | OrderConnectionDiscount_code | OrderConnectionQuantity | OrderConnectionPublished_at | createOrderPayload | updateOrderPayload | deleteOrderPayload | Packinging | PackingingConnection | PackingingAggregator | PackingingGroupBy | PackingingConnectionId | PackingingConnectionCreated_at | PackingingConnectionUpdated_at | PackingingConnectionName | PackingingConnectionIsActive | PackingingConnectionPublished_at | createPackingingPayload | updatePackingingPayload | deletePackingingPayload | PreferredCategory | PreferredCategoryConnection | PreferredCategoryAggregator | PreferredCategoryGroupBy | PreferredCategoryConnectionId | PreferredCategoryConnectionCreated_at | PreferredCategoryConnectionUpdated_at | PreferredCategoryConnectionName | PreferredCategoryConnectionIsActive | PreferredCategoryConnectionStore | PreferredCategoryConnectionPublished_at | createPreferredCategoryPayload | updatePreferredCategoryPayload | deletePreferredCategoryPayload | ProductImage | ProductImageConnection | ProductImageAggregator | ProductImageGroupBy | ProductImageConnectionId | ProductImageConnectionCreated_at | ProductImageConnectionUpdated_at | ProductImageConnectionImage | ProductImageConnectionPublished_at | createProductImagePayload | updateProductImagePayload | deleteProductImagePayload | ProductProperties | ProductPropertiesConnection | ProductPropertiesAggregator | ProductPropertiesGroupBy | ProductPropertiesConnectionId | ProductPropertiesConnectionCreated_at | ProductPropertiesConnectionUpdated_at | ProductPropertiesConnectionName | ProductPropertiesConnectionCategory | ProductPropertiesConnectionIsActive | ProductPropertiesConnectionStore | ProductPropertiesConnectionPublished_at | createProductPropertyPayload | updateProductPropertyPayload | deleteProductPropertyPayload | ProductSize | ProductSizeConnection | ProductSizeAggregator | ProductSizeAggregatorSum | ProductSizeAggregatorAvg | ProductSizeAggregatorMin | ProductSizeAggregatorMax | ProductSizeGroupBy | ProductSizeConnectionId | ProductSizeConnectionCreated_at | ProductSizeConnectionUpdated_at | ProductSizeConnectionName | ProductSizeConnectionIsActive | ProductSizeConnectionPrice | ProductSizeConnectionDiscount_type | ProductSizeConnectionDiscount | ProductSizeConnectionPublished_at | createProductSizePayload | updateProductSizePayload | deleteProductSizePayload | ProductType | ProductTypeConnection | ProductTypeAggregator | ProductTypeGroupBy | ProductTypeConnectionId | ProductTypeConnectionCreated_at | ProductTypeConnectionUpdated_at | ProductTypeConnectionName | ProductTypeConnectionIsActive | ProductTypeConnectionStore | ProductTypeConnectionPublished_at | createProductTypePayload | updateProductTypePayload | deleteProductTypePayload | Product | ProductConnection | ProductAggregator | ProductAggregatorSum | ProductAggregatorAvg | ProductAggregatorMin | ProductAggregatorMax | ProductGroupBy | ProductConnectionId | ProductConnectionCreated_at | ProductConnectionUpdated_at | ProductConnectionProductName | ProductConnectionDescription | ProductConnectionIsActive | ProductConnectionPrice | ProductConnectionCreatedDate | ProductConnectionCreatedBy | ProductConnectionOrderDetail | ProductConnectionItemCode | ProductConnectionIngredients | ProductConnectionAllergen | ProductConnectionProductimagee | ProductConnectionPublished_at | createProductPayload | updateProductPayload | deleteProductPayload | PromotionDetail | PromotionDetailConnection | PromotionDetailAggregator | PromotionDetailGroupBy | PromotionDetailConnectionId | PromotionDetailConnectionCreated_at | PromotionDetailConnectionUpdated_at | PromotionDetailConnectionFree_product | PromotionDetailConnectionProduct_name | PromotionDetailConnectionPublished_at | createPromotionDetailPayload | updatePromotionDetailPayload | deletePromotionDetailPayload | Promotions | PromotionsConnection | PromotionsAggregator | PromotionsGroupBy | PromotionsConnectionId | PromotionsConnectionCreated_at | PromotionsConnectionUpdated_at | PromotionsConnectionName | PromotionsConnectionOfferimage | PromotionsConnectionIsActive | PromotionsConnectionProduct_category | PromotionsConnectionDescription | PromotionsConnectionDiscount_type | PromotionsConnectionPublished_at | createPromotionPayload | updatePromotionPayload | deletePromotionPayload | Reviews | ReviewsConnection | ReviewsAggregator | ReviewsGroupBy | ReviewsConnectionId | ReviewsConnectionCreated_at | ReviewsConnectionUpdated_at | ReviewsConnectionCustomerReviews | ReviewsConnectionRating | ReviewsConnectionIsActive | ReviewsConnectionVendorAnswer | ReviewsConnectionUsersPermissionsUser | ReviewsConnectionStore | ReviewsConnectionPublished_at | createReviewPayload | updateReviewPayload | deleteReviewPayload | Settings | SettingsConnection | SettingsAggregator | SettingsGroupBy | SettingsConnectionId | SettingsConnectionCreated_at | SettingsConnectionUpdated_at | SettingsConnectionSettingName | SettingsConnectionSettingValue | SettingsConnectionIsActive | SettingsConnectionPublished_at | createSettingPayload | updateSettingPayload | deleteSettingPayload | State | StateConnection | StateAggregator | StateGroupBy | StateConnectionId | StateConnectionCreated_at | StateConnectionUpdated_at | StateConnectionStateName | StateConnectionIsActive | StateConnectionPublished_at | createStatePayload | updateStatePayload | deleteStatePayload | Store | StoreConnection | StoreAggregator | StoreAggregatorSum | StoreAggregatorAvg | StoreAggregatorMin | StoreAggregatorMax | StoreGroupBy | StoreConnectionId | StoreConnectionCreated_at | StoreConnectionUpdated_at | StoreConnectionStoreName | StoreConnectionUsers_permissions_user | StoreConnectionImage | StoreConnectionSelf_delivery | StoreConnectionLongitude | StoreConnectionLatitude | StoreConnectionStoreopen | StoreConnectionStoreClose | StoreConnectionAllergen | StoreConnectionCommission | StoreConnectionDelivery_distance | StoreConnectionCooking_experience | StoreConnectionSecondaryContact | StoreConnectionPublished_at | createStorePayload | updateStorePayload | deleteStorePayload | UserType | UserTypeConnection | UserTypeAggregator | UserTypeGroupBy | UserTypeConnectionId | UserTypeConnectionCreated_at | UserTypeConnectionUpdated_at | UserTypeConnectionName | UserTypeConnectionIsActive | UserTypeConnectionPublished_at | createUserTypePayload | updateUserTypePayload | deleteUserTypePayload | I18NLocale | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionFirstName | UsersPermissionsUserConnectionLastName | UsersPermissionsUserConnectionDOB | UsersPermissionsUserConnectionIneracEmail | UsersPermissionsUserConnectionVendorCode | UsersPermissionsUserConnectionUserImage | UsersPermissionsUserConnectionDocumentsRequired | UsersPermissionsUserConnectionStore | UsersPermissionsUserConnectionCatalogApprove | UsersPermissionsUserConnectionCellPhone | UsersPermissionsUserConnectionHomephone | UsersPermissionsUserConnectionHomeStreet | UsersPermissionsUserConnectionHomeUnitNo | UsersPermissionsUserConnectionHomeCity | UsersPermissionsUserConnectionHomePostalCode | UsersPermissionsUserConnectionHomeProvince | UsersPermissionsUserConnectionPickStreet | UsersPermissionsUserConnectionPickUnitNo | UsersPermissionsUserConnectionPickCity | UsersPermissionsUserConnectionPickPostalCode | UsersPermissionsUserConnectionPickProvince | UsersPermissionsUserConnectionProfileApproved | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  addressType(id: ID!, publicationState: PublicationState): AddressType
  addressTypes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [AddressType]
  addressTypesConnection(sort: String, limit: Int, start: Int, where: JSON): AddressTypeConnection
  address(id: ID!, publicationState: PublicationState): Address
  addresses(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Address]
  addressesConnection(sort: String, limit: Int, start: Int, where: JSON): AddressConnection
  city(id: ID!, publicationState: PublicationState): City
  cities(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [City]
  citiesConnection(sort: String, limit: Int, start: Int, where: JSON): CityConnection
  commission(id: ID!, publicationState: PublicationState): Commission
  commissions(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Commission]
  commissionsConnection(sort: String, limit: Int, start: Int, where: JSON): CommissionConnection
  country(id: ID!, publicationState: PublicationState): Country
  countries(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Country]
  countriesConnection(sort: String, limit: Int, start: Int, where: JSON): CountryConnection
  deleveiryCharge(id: ID!, publicationState: PublicationState): DeleveiryCharges
  deleveiryCharges(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DeleveiryCharges]
  deleveiryChargesConnection(sort: String, limit: Int, start: Int, where: JSON): DeleveiryChargesConnection
  deliverType(id: ID!, publicationState: PublicationState): DeliverType
  deliverTypes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DeliverType]
  deliverTypesConnection(sort: String, limit: Int, start: Int, where: JSON): DeliverTypeConnection
  deliver(id: ID!, publicationState: PublicationState): Delivers
  delivers(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Delivers]
  deliversConnection(sort: String, limit: Int, start: Int, where: JSON): DeliversConnection
  deliveryDay(id: ID!, publicationState: PublicationState): DeliveryDays
  deliveryDays(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DeliveryDays]
  deliveryDaysConnection(sort: String, limit: Int, start: Int, where: JSON): DeliveryDaysConnection
  menuCategory(id: ID!, publicationState: PublicationState): MenuCategory
  menuCategories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MenuCategory]
  menuCategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): MenuCategoryConnection
  orderDetail(id: ID!, publicationState: PublicationState): OrderDetail
  orderDetails(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [OrderDetail]
  orderDetailsConnection(sort: String, limit: Int, start: Int, where: JSON): OrderDetailConnection
  orderHistory(id: ID!, publicationState: PublicationState): OrderHistory
  orderHistories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [OrderHistory]
  orderHistoriesConnection(sort: String, limit: Int, start: Int, where: JSON): OrderHistoryConnection
  orderStatus(id: ID!, publicationState: PublicationState): OrderStatus
  orderStatuses(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [OrderStatus]
  orderStatusesConnection(sort: String, limit: Int, start: Int, where: JSON): OrderStatusConnection
  order(id: ID!, publicationState: PublicationState): Order
  orders(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Order]
  ordersConnection(sort: String, limit: Int, start: Int, where: JSON): OrderConnection
  packinging(id: ID!, publicationState: PublicationState): Packinging
  packingings(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Packinging]
  packingingsConnection(sort: String, limit: Int, start: Int, where: JSON): PackingingConnection
  preferredCategory(id: ID!, publicationState: PublicationState): PreferredCategory
  preferredCategories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [PreferredCategory]
  preferredCategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): PreferredCategoryConnection
  productImage(id: ID!, publicationState: PublicationState): ProductImage
  productImages(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductImage]
  productImagesConnection(sort: String, limit: Int, start: Int, where: JSON): ProductImageConnection
  productProperty(id: ID!, publicationState: PublicationState): ProductProperties
  productProperties(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductProperties]
  productPropertiesConnection(sort: String, limit: Int, start: Int, where: JSON): ProductPropertiesConnection
  productSize(id: ID!, publicationState: PublicationState): ProductSize
  productSizes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductSize]
  productSizesConnection(sort: String, limit: Int, start: Int, where: JSON): ProductSizeConnection
  productType(id: ID!, publicationState: PublicationState): ProductType
  productTypes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductType]
  productTypesConnection(sort: String, limit: Int, start: Int, where: JSON): ProductTypeConnection
  product(id: ID!, publicationState: PublicationState): Product
  products(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Product]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductConnection
  promotionDetail(id: ID!, publicationState: PublicationState): PromotionDetail
  promotionDetails(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [PromotionDetail]
  promotionDetailsConnection(sort: String, limit: Int, start: Int, where: JSON): PromotionDetailConnection
  promotion(id: ID!, publicationState: PublicationState): Promotions
  promotions(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Promotions]
  promotionsConnection(sort: String, limit: Int, start: Int, where: JSON): PromotionsConnection
  review(id: ID!, publicationState: PublicationState): Reviews
  reviews(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Reviews]
  reviewsConnection(sort: String, limit: Int, start: Int, where: JSON): ReviewsConnection
  setting(id: ID!, publicationState: PublicationState): Settings
  settings(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Settings]
  settingsConnection(sort: String, limit: Int, start: Int, where: JSON): SettingsConnection
  state(id: ID!, publicationState: PublicationState): State
  states(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [State]
  statesConnection(sort: String, limit: Int, start: Int, where: JSON): StateConnection
  store(id: ID!, publicationState: PublicationState): Store
  stores(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Store]
  storesConnection(sort: String, limit: Int, start: Int, where: JSON): StoreConnection
  userType(id: ID!, publicationState: PublicationState): UserType
  userTypes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UserType]
  userTypesConnection(sort: String, limit: Int, start: Int, where: JSON): UserTypeConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createAddressType(input: createAddressTypeInput): createAddressTypePayload
  updateAddressType(input: updateAddressTypeInput): updateAddressTypePayload
  deleteAddressType(input: deleteAddressTypeInput): deleteAddressTypePayload
  createAddress(input: createAddressInput): createAddressPayload
  updateAddress(input: updateAddressInput): updateAddressPayload
  deleteAddress(input: deleteAddressInput): deleteAddressPayload
  createCity(input: createCityInput): createCityPayload
  updateCity(input: updateCityInput): updateCityPayload
  deleteCity(input: deleteCityInput): deleteCityPayload
  createCommission(input: createCommissionInput): createCommissionPayload
  updateCommission(input: updateCommissionInput): updateCommissionPayload
  deleteCommission(input: deleteCommissionInput): deleteCommissionPayload
  createCountry(input: createCountryInput): createCountryPayload
  updateCountry(input: updateCountryInput): updateCountryPayload
  deleteCountry(input: deleteCountryInput): deleteCountryPayload
  createDeleveiryCharge(input: createDeleveiryChargeInput): createDeleveiryChargePayload
  updateDeleveiryCharge(input: updateDeleveiryChargeInput): updateDeleveiryChargePayload
  deleteDeleveiryCharge(input: deleteDeleveiryChargeInput): deleteDeleveiryChargePayload
  createDeliverType(input: createDeliverTypeInput): createDeliverTypePayload
  updateDeliverType(input: updateDeliverTypeInput): updateDeliverTypePayload
  deleteDeliverType(input: deleteDeliverTypeInput): deleteDeliverTypePayload
  createDeliver(input: createDeliverInput): createDeliverPayload
  updateDeliver(input: updateDeliverInput): updateDeliverPayload
  deleteDeliver(input: deleteDeliverInput): deleteDeliverPayload
  createDeliveryDay(input: createDeliveryDayInput): createDeliveryDayPayload
  updateDeliveryDay(input: updateDeliveryDayInput): updateDeliveryDayPayload
  deleteDeliveryDay(input: deleteDeliveryDayInput): deleteDeliveryDayPayload
  createMenuCategory(input: createMenuCategoryInput): createMenuCategoryPayload
  updateMenuCategory(input: updateMenuCategoryInput): updateMenuCategoryPayload
  deleteMenuCategory(input: deleteMenuCategoryInput): deleteMenuCategoryPayload
  createOrderDetail(input: createOrderDetailInput): createOrderDetailPayload
  updateOrderDetail(input: updateOrderDetailInput): updateOrderDetailPayload
  deleteOrderDetail(input: deleteOrderDetailInput): deleteOrderDetailPayload
  createOrderHistory(input: createOrderHistoryInput): createOrderHistoryPayload
  updateOrderHistory(input: updateOrderHistoryInput): updateOrderHistoryPayload
  deleteOrderHistory(input: deleteOrderHistoryInput): deleteOrderHistoryPayload
  createOrderStatus(input: createOrderStatusInput): createOrderStatusPayload
  updateOrderStatus(input: updateOrderStatusInput): updateOrderStatusPayload
  deleteOrderStatus(input: deleteOrderStatusInput): deleteOrderStatusPayload
  createOrder(input: createOrderInput): createOrderPayload
  updateOrder(input: updateOrderInput): updateOrderPayload
  deleteOrder(input: deleteOrderInput): deleteOrderPayload
  createPackinging(input: createPackingingInput): createPackingingPayload
  updatePackinging(input: updatePackingingInput): updatePackingingPayload
  deletePackinging(input: deletePackingingInput): deletePackingingPayload
  createPreferredCategory(input: createPreferredCategoryInput): createPreferredCategoryPayload
  updatePreferredCategory(input: updatePreferredCategoryInput): updatePreferredCategoryPayload
  deletePreferredCategory(input: deletePreferredCategoryInput): deletePreferredCategoryPayload
  createProductImage(input: createProductImageInput): createProductImagePayload
  updateProductImage(input: updateProductImageInput): updateProductImagePayload
  deleteProductImage(input: deleteProductImageInput): deleteProductImagePayload
  createProductProperty(input: createProductPropertyInput): createProductPropertyPayload
  updateProductProperty(input: updateProductPropertyInput): updateProductPropertyPayload
  deleteProductProperty(input: deleteProductPropertyInput): deleteProductPropertyPayload
  createProductSize(input: createProductSizeInput): createProductSizePayload
  updateProductSize(input: updateProductSizeInput): updateProductSizePayload
  deleteProductSize(input: deleteProductSizeInput): deleteProductSizePayload
  createProductType(input: createProductTypeInput): createProductTypePayload
  updateProductType(input: updateProductTypeInput): updateProductTypePayload
  deleteProductType(input: deleteProductTypeInput): deleteProductTypePayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createPromotionDetail(input: createPromotionDetailInput): createPromotionDetailPayload
  updatePromotionDetail(input: updatePromotionDetailInput): updatePromotionDetailPayload
  deletePromotionDetail(input: deletePromotionDetailInput): deletePromotionDetailPayload
  createPromotion(input: createPromotionInput): createPromotionPayload
  updatePromotion(input: updatePromotionInput): updatePromotionPayload
  deletePromotion(input: deletePromotionInput): deletePromotionPayload
  createReview(input: createReviewInput): createReviewPayload
  updateReview(input: updateReviewInput): updateReviewPayload
  deleteReview(input: deleteReviewInput): deleteReviewPayload
  createSetting(input: createSettingInput): createSettingPayload
  updateSetting(input: updateSettingInput): updateSettingPayload
  deleteSetting(input: deleteSettingInput): deleteSettingPayload
  createState(input: createStateInput): createStatePayload
  updateState(input: updateStateInput): updateStatePayload
  deleteState(input: deleteStateInput): deleteStatePayload
  createStore(input: createStoreInput): createStorePayload
  updateStore(input: updateStoreInput): updateStorePayload
  deleteStore(input: deleteStoreInput): deleteStorePayload
  createUserType(input: createUserTypeInput): createUserTypePayload
  updateUserType(input: updateUserTypeInput): updateUserTypePayload
  deleteUserType(input: deleteUserTypeInput): deleteUserTypePayload

  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
